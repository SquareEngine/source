<!DOCTYPE html>
<html>

<head>

<meta charset = "UTF-8">
<title>Square Engine - API</title>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<!-- <script src="../squareEngine.js"></script> -->
<script src="../scripts/updateLinks.js"></script>
<link rel= "stylesheet" type="text/css" href="../css/main.css">

<script> 
	$( document ).ready(function(){
		$("div#headerDiv").load("header.html", function(){
			updateHeader();
		}); 
		$("div#footerDiv").load("footer.html", function(){
			updateFooter();
		}); 
	});
</script> 

</head>

<body>

	<div id="wrapper">	

		<div id="headerDiv"></div>

		<div id="hero">
			<div class="normal" id="mainBody">
				<h2>API</h2>
				<div id="aboutLogo">
					<img src="../images/logo.png"   width="60">
				</div>
				<p id="fullText">
					<a href="https://github.com/SquareEngine/source">Square engine </a>is available online at Github.
					If you have question setting up a game please check the <a href="tutorial.html">tutorial</a> page. 
				</p>

				<h2>The 2 main classes</h2>
				<img src="../images/api0.PNG" alt="" width="300">
				<p id="fullText">
					The gameGrid class is the actual game engine itself. It creates and maintains the gameObjects, input events and canvas methods. The gameGrid tick() methods is called 60 times a second. The tick will then call the appropriate methods depending on its game state.
				</p>
				<p id="fullText">
					The states are: START, UPDATE, PAUSED and GAMEOVER. The STARTS state will just render the start screen and wait for input. The UPDATE is the running game and it will update all its game objects an drender them. The PAUSED state skips gameObject updates but calls the render method. The GAMEOVER stops all updates.
				</p>
				<p id="fullText">
					The gameObject is just a simple square that can be created by the gameGrid. You can change it's position, size, color, speed and many other attributes. You must override a few gameObject methods to get it to do stuff. The update() method is called 60 times per frame and it's mostly used to define behavior. 
				</p>

				<h2>Extended gameObjects</h2>
				<img src="../images/api1.PNG" alt="" width="500">
				<p id="fullText">
					Besides the basic gameObject, the library comes with 3 extended gameObjects. gameObjectMove is just a simple gameObject but be default it takes keyboard inputs to move. gameObjectPaddle is a gameObjectMove but with screen limits. gameObjectBall is a gameObject that keeps moving and bounces against the screen edges. These 3 classes are odeal to make simple games. 
				</p>
				<h2>Other classes</h2>
				<img src="../images/api2.PNG" alt="" width="400">
				<p id="fullText">
					The library also comes with a few convenience classes: 2D Vector class with methods to do vector math. A boundingBox class to help with collision detection. A square class that extends boundingBox and adds rendering and color methods. An RGB color class to help set gameObject colors. 
				</p>

				<h2>GameGrid methods</h2>
				
				<p id="fullText">
					Here's a list of the most important methods you want to override to create game behavior. These methods don't do anything so you can use them anyway you like. The most important one is probably update(). This method is called 60 times per second while the game is running.
				</p>
				<img src="../images/api/gameGrid0.PNG" alt="" width="700">

				<p id="fullText">
					These methods can be redefined to render squares or text at start, update, pause or gameOver. They are called 60 times per second.
				</p>
				<img src="../images/api/gameGrid1.PNG" alt="" width="700">

				<p id="fullText">
					These methods are called when user inputs keyboard or mouse data. They must have at least 1 argument, which is the input data. 
				</p>
				<img src="../images/api/gameGrid2.PNG" alt="" width="700">

				<p id="fullText">
					These methods are NOT meant to be overriden. You use them to get data from the gameGrid.
				</p>
				<img src="../images/api/gameGrid3.PNG" alt="" width="700">

				<p id="fullText">
					These methods are are used to create and get gameObjects form the gameGrid. You can also add your new gameObject classes to the gameGrid factory. That way the gameGrid can create and keep track of your new gameObject.
				</p>
				<img src="../images/api/gameGrid4.PNG" alt="" width="700">

				<p>
					Use these to print HTML text to the logger element.
				</p>
				<img src="../images/api/gameGrid5.PNG" alt="" width="700">

				<p id="fullText">
					You can use these methods to render squares and text on the screen.
				</p>
				<img src="../images/api/gameGrid6.PNG" alt="" width="700">

				<p id="fullText">
					If you want your game to be tiled based you can use these methods to help you get and set tile data. The gameGrid has a tile array that keeps track of tile objects. 
				</p>
				<img src="../images/api/gameGrid7.PNG" alt="" width="700">

				<h2>GameObject methods</h2>

				<p id="fullText">
					Same as the gameGrid the gameObject have the folowing input methods and methods meant to be overriden. The only difference is that you must have an argument on some of these methods. When they are called the gameGrid passes itself as the first argument. That way you can access the gameGrid and other gameObjects inside the gameGrid. 
				</p>
				<img src="../images/api/go0.PNG" alt="" width="700">

				<p id="fullText">
					These methods are meant to turn on/off some gameObject behavior or to get gameObject data.
				</p>
				<img src="../images/api/go1.PNG" alt="" width="700">

				<p id="fullText">
					The gameObject at creation has a 1 unit square by default, but you can use these methods to add/remove/edit them. 
				</p>
				<img src="../images/api/go2.PNG" alt="" width="700">

				<p >
					Methods for changing the gameObject color.
				</p>
				<img src="../images/api/go3.PNG" alt="" width="500">

				<p id="fullText">
					You can use these methods to change your game object direction and position. The direction is a Vector that represents the direction that your gameObject is aiming to. The position is a Vector that represents its position in the screen X & Y plane.
				</p>
				<img src="../images/api/go4.PNG" alt="" width="700">

				<p id="fullText">
					You can use the screenCheck and check if a given Vector goes beyond the screen limit. When a gameObject goes past the screen it will call one of the 4 following screen methods. You can override them to create a game behavior.
				</p>
				<img src="../images/api/go5.PNG" alt="" width="700">

				<p id="fullText">
					A gameObject has the following methods to check for collision against Vectors and other gameObjects. Your gameObject uses its boundingBox to check collision. If you disable auto update boundingBox you can always call updateBoundingBox() to do so.
				</p>
				<img src="../images/api/go6.PNG" alt="" width="700">

				<p id="fullText">
					Finally a gameObject has a few methods to work with tiles. Please look at gameGrid tile methods for more information.
				</p>
				<img src="../images/api/go7.PNG" alt="" width="400">

				<br>
				<a href="API.html">BACK TO TOP</a> 
				<br>
				<br>
				<img src="../images/logo.png"   width="60">
			
			</div>
		</div>

		<div id="footerDiv"></div>

	</div>

	

</body>

</html>